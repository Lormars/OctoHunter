package quirks

import (
	"fmt"
	"net/http"
	"net/url"
	"strings"

	"github.com/lormars/octohunter/common"
	"github.com/lormars/octohunter/common/clients"
	"github.com/lormars/octohunter/internal/cacher"
	"github.com/lormars/octohunter/internal/checker"
	"github.com/lormars/octohunter/internal/comparer"
	"github.com/lormars/octohunter/internal/generator"
	"github.com/lormars/octohunter/internal/matcher"
	"github.com/lormars/octohunter/internal/notify"
)

//Quirks is a general scanner that scan for intersting http responses.
//It does not mean that the responses are vulnerabilities, but they are interesting.

var result *common.ServerResult

func CheckQuirks(res *common.ServerResult) {
	//there are just so many websites with the same quirks on all the endpoints under a path,
	//so need to cache a little more agressively to cache the first path as well
	// firstPath, err := cacher.GetFirstPath(res.Url)
	// if err != nil {
	// 	if !cacher.CheckCache(res.Url, "quirks") {
	// 		return
	// 	}
	// } else {
	// 	if !cacher.CheckCache(firstPath, "quirks") {
	// 		return
	// 	}
	// }

	if !cacher.CheckCache(res.Url, "quirks") {
		return
	}

	result = res
	//too much false positive
	//doubleHTML()

	jsonwithHTML()
	leakenv()
	isdynamic()
}

func doubleHTML() {
	contentType := result.Headers.Get("Content-Type")
	if contentType == "" {
		return
	}
	if !checker.CheckMimeType(contentType, "text/html") {
		return
	}
	if strings.Count(result.Body, "</html>") > 1 {
		//if result.Depth > 0, it means this url is the result of a crawl
		//then it is worthy to crawl it to get further endpoint
		//if result.Depth = 0, then it must already be crawled by crawler, so no need to crawl it again
		if result.Depth > 0 {
			common.CrawlP.PublishMessage(result)
		}

		msg := fmt.Sprintf("[Quirks] Double HTML in %s", result.Url)
		common.OutputP.PublishMessage(msg)
		notify.SendMessage(msg)
	}
}

func jsonwithHTML() {
	contentType := result.Headers.Get("Content-Type")
	if contentType == "" {
		return
	}
	if !checker.CheckMimeType(contentType, "text/html") {
		return
	}
	if strings.HasPrefix(result.Body, "{") || strings.HasPrefix(result.Body, "[") {
		msg := fmt.Sprintf("[Quirks] JSON with HTML mime in %s", result.Url)
		common.OutputP.PublishMessage(msg)
		notify.SendMessage(msg)
	}
}

func leakenv() {
	if strings.Count(result.Body, "HTTP_") > 2 {
		msg := fmt.Sprintf("[Quirks] HTTP_ ENV leak in %s", result.Url)
		common.OutputP.PublishMessage(msg)
		notify.SendMessage(msg)
	}
}

func isdynamic() {
	if !checker.CheckAccess(result) {
		return
	}
	cacheBuster, err := generator.GenerateSignature()
	if err != nil {
		return
	}

	parsedURL, err := url.Parse(result.Url)
	if err != nil {
		return
	}
	queries := parsedURL.Query()
	queries.Set("cachebuster", cacheBuster)
	parsedURL.RawQuery = queries.Encode()

	req, err := http.NewRequest("GET", parsedURL.String(), nil)
	if err != nil {
		return
	}
	resp1, err := checker.CheckServerCustom(req, clients.NoRedirectClient)
	if err != nil {
		return
	}
	resp2, err := checker.CheckServerCustom(req, clients.NoRedirectClient)
	if err != nil {
		return
	}

	//first check if it is dynamically generated by comparing two responses
	same, _ := comparer.CompareResponse(resp1, resp2)
	//then pass to path confusion if there is no cache header or no cache hit
	if !same && (!matcher.HeaderKeyContainsSignature(resp2, "cache") || !matcher.HeaderValueContainsSignature(resp2, "hit")) {
		common.PathConfuseP.PublishMessage(result.Url)
	}

}
